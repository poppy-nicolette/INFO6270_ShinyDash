---
title: "Chapter 12:"
subtitle: "Layouts and Dashboards"
format: html
editor: visual
---

In this chapter, we will look at how to make your do stuff, respond, and calculate multiple tables and visualizations

## Reactive pages

### basics of reactivity

reactivity refers to the ability of an app to recaculate or perform some action when an input is changed. In a non-reactive Shiny app, all calculations are run when the session begins. However, if you want a user to change an input and display a new calculated resullt, then reactivity in Shiny apps allow only that part of the app to be computed and redisplayed, not the entire app. This is important for making things fast and able to display immediate changes.

#### server \<- function(input, output, session)

the first thing you'll see is the session argument in the function(). you can read a detailed account of it here:

But this is what we'll use in the server function to make sure there is a session state that is active and updates the webpage when asked.

\[insert basic structure for reactivity\]

#### two different types of programming: imperative and declarative

imperative is like the analysis functions you've been running. you write a series of commands and R executes them. You see errors if something doesn't match. The UI layout is imperative. you write code that says where something will be, like a radio button or sidebar text.

declarative provides options for the program if conditions are right. So, it might execute the code if conditions are met. This is what we see on the server side function. Its a series of codes that will run if something happens in the UI.

declarative is harder to identify errors, typos, etc. because it running depends on the conditions provided for it.

#### execution order

Unlike imperative, declarative coding such as in the `server`, run only when needed. so order is not as important in the `server` function. However, this can make code very difficult to read for humans as we tend to assume top to bottom.

Keeping things lightweight

Data can be very large. To prevent this from slowing down the application, every time a new input is sent to the server function, do as much of your data cleaning and manipulation outside of the ShinyApp as possible. Of course, there are just some situations where this is not possible. But as a general rule, keep it minimal inside the ShinyApp. However, you can run code before the `ui` and `server` functions if data needs to be cleaned.

\[insert example code\]

#### Internal Events

##### reactive()

##### eventReactive()

On click events

\[insert eventReactive() with an action button\]

\[revisit download code\]

#### External Events

##### observerEvent()

control events outside the app, such sending a request to an API, updating a database, or saving a file. These events are called observers and use the `observeEvent()` function.

two arguments: `eventExpr` and `handlerExpr`

first input is the input or expression to take a dependency upon, the second is the code that willl be executed.

observeEvent() functions do not update the HTML in the browser. Note that the following code changes in the HTML to the webpage with the reactive and also prints something in the console.

\[insert code showing reactive and observeEvent...\]

\[insert results of reactive\]

\[insert results of observeEvent\] - maybe a popup?

#### What is session?

Session is an optional argument passed to the server function that enables inputs or outputs related to the current instance of the app to be used. You may see some examples with this, such as with the downloadHandler() function.

If you see it in a code example, its likely there to and input or output that is unique to this instance and do something with it. You can experiment with removing it or adding it back in with this code;

\[insert session code example\]

### Summary

Reactivity is different due to the nature of declarative programming. It makes code less complex and provdies conditions that could be met, rather than a linear progression of code to be executed. We use reactivity so that people can change inputs and receive different outputs or make external actions happen.

Recognizing reactive functions of eventReactive() and observeEvent() and why its used on the back-end of a Shiny app will help in diagnosing and designing your code. The file upload input and the download button output are two examples where reactivity can be seen.

-   session is added as an optional argument to the server function call

-   you can put code before the shiny code to reduce calculation time.

-   `eventReactive()` is used for internal events triggering a change.

-   `observeEvent()` is used for triggering external events, such as downloading a file to the users downloads folder.

## DataTables

In this section, we are going to explore importing data and displaying it in a DataTable using the DT library. This is different than the data.table library. The DT library makes a lovely table that can be searched, filtered, and sorted which is great for data exploration. You can find more info [here](https://shiny.rstudio.com/articles/datatables.html) and [here](https://rstudio.github.io/DT/shiny.html) for the DT documentation.

``` R
library(shiny)
library(DT)

ui <- fluidPage(
  h2("Some data about flowers"),
  DT::dataTableOutput("table_1")

)#close fluidPage

server <- function(input, output) {
  output$table_1 = DT::renderDataTable({
  iris
  })#close output

}#close server

shinyApp(ui, server)
```

## Computation output

But what if we wanted to perform some operations on the data, such as to use the summarizing functions you did in earlier chapters on the mtcars dataset? In the code below, we first import some data from a remote location, then create a DataTable for exploration. Then we summarize the data.

``` R
library(shiny)
library(DT)
library(tidyverse)


path <- "https://raw.githubusercontent.com/fivethirtyeight/data/master/comic-characters/marvel-wikia-data.csv"

# This will read the first sheet of the Excel file
comics_data <- read_csv(path)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      h2("How to use DataTables from the DT library"),
      br(),
      p("To the right is a dataset displayed as a DataTable"), 
      p("This dataset is from the fivethirtyeight GitHub repository.")
    ),#close sidebarPanel
    mainPanel(
  h2("the dataset"),
  br(),
  
  DT::dataTableOutput("table_1"), 
  
  
    )#close mainPanel
  )#close sidebarLayout
)#close fluidPage

server <- function(input, output) {
  data_to_display <- comics_data

  output$table_1 <- renderDataTable({
   (data_to_display)
    })
  
}#close server

shinyApp(ui, server)
```

First, we can drop urlslug, and page_id. We also want to correct the column names.

``` R
library(shiny)
library(DT)
library(tidyverse)


path <- "https://raw.githubusercontent.com/fivethirtyeight/data/master/comic-characters/marvel-wikia-data.csv"

# This will read the first sheet of the Excel file
comics_data <- read_csv(path)

comics_data <- select(comics_data, "name", "ID", "ALIGN", "EYE", 
                      "HAIR", "SEX", "GSM", "ALIVE", "APPEARANCES",
                      "FIRST APPEARANCE", "Year" ) %>% 
                rename(Name = name,
                       Alignment=ALIGN,
                       Eye = EYE, 
                       Hair = HAIR,
                       Gender = SEX, 
                       Gender_or_sexual_identity = GSM,
                       Status = ALIVE, 
                       Appearances = APPEARANCES,
                       First_appearance = 'FIRST APPEARANCE')

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      h2("How to use DataTables from the DT library"),
      br(),
      p("To the right is a dataset displayed as a DataTable"), 
      p("This dataset is from the fivethirtyeight GitHub repository.")
    ),#close sidebarPanel
    mainPanel(
      h2("the dataset"),
      br(),
      DT::dataTableOutput("table_1")#close dataTableOutput
  
    )#close mainPanel
  )#close sidebarLayout
)#close fluidPage

server <- function(input, output) {
  data_to_display <- comics_data

  output$table_1 <- renderDataTable(
   data_to_display,
    options = list(
      scrollX = TRUE, 
      scrollY = TRUE,
      autoWidth = TRUE,
      rownames = FALSE)
    ) #close renderDataTable
}#close server

shinyApp(ui, server)
```

You can see from this example, there are new options added to the `renderDataTable()` function. We also modified our data *before* the `ui`. You can find an excellent explanation of options as well as integration with the formattable library from [this blog](https://clarewest.github.io/blog/post/making-tables-shiny/).

## Visualization

Ok, we have some table options with the data.table library and the more dynamic DT library. Let's seem what this data looks like. We're going to introduce the ggplot library, introduce the igraph llibrary for networks, and provide some resources for plotly and leaflet for further exploration in visualilzation.

### Basic graphs

### Network

## Dashboards

flexdashboard: [link](https://pkgs.rstudio.com/flexdashboard/articles/flexdashboard.html "dashboard basics")

uses R Markdown, easy, support static or dynamic visualizations, and uses CSS flexbox layout. (what's that?)

shinydashboard: [link](https://rstudio.github.io/shinydashboard/get_started.html "shiny dashboard")

shinuy UI code, not quite as easy, dynamic visualizations, and uses Bootstrap grid layout

### multiple graphs, tables, networks

### styling dashboards

#### The shinydashboard way

#### using shiny.semantic

https://appsilon.github.io/shiny.semantic/
