---
title: "Chapter 12:"
subtitle: "Layouts and Dashboards"
format: html
editor: visual
---

In this chapter, we will look at how to make your do stuff, respond, and calculate multiple tables and visualizations

## Reactive pages

### basics of reactivity

reactivity refers to the ability of an app to recaculate or perform some action when an input is changed. In a non-reactive Shiny app, all calculations are run when the session begins. However, if you want a user to change an input and display a new calculated resullt, then reactivity in Shiny apps allow only that part of the app to be computed and redisplayed, not the entire app. This is important for making things fast and able to display immediate changes.

#### server \<- function(input, output, session)

the first thing you'll see is the session argument in the function(). you can read a detailed account of it here:

But this is what we'll use in the server function to make sure there is a session state that is active and updates the webpage when asked.

\[insert basic structure for reactivity\]

#### two different types of programming: imperative and declarative

imperative is like the analysis functions you've been running. you write a series of commands and R executes them. You see errors if something doesn't match. The UI layout is imperative. you write code that says where something will be, like a radio button or sidebar text.

declarative provides options for the program if conditions are right. So, it might execute the code if conditions are met. This is what we see on the server side function. Its a series of codes that will run if something happens in the UI.

declarative is harder to identify errors, typos, etc. because it running depends on the conditions provided for it.

#### execution order

Unlike imperative, declarative coding such as in the `server`, run only when needed. so order is not as important in the `server` function. However, this can make code very difficult to read for humans as we tend to assume top to bottom.

Keeping things lightweight

Data can be very large. To prevent this from slowing down the application, every time a new input is sent to the server function, do as much of your data cleaning and manipulation outside of the ShinyApp as possible. Of course, there are just some situations where this is not possible. But as a general rule, keep it minimal inside the ShinyApp. However, you can run code before the `ui` and `server` functions if data needs to be cleaned.

\[insert example code\]

#### Internal Events

##### eventReactive()

On click events

\[insert eventReactive() with an action button\]

\[revisit download code\]

#### External Events

##### observerEvent()

control events outside the app, such sending a request to an API, updating a database, or saving a file. These events are called observers and use the `observeEvent()` function.

two arguments: `eventExpr` and `handlerExpr`

first input is the input or expression to take a dependency upon, the second is the code that willl be executed.

observeEvent() functions do not update the HTML in the browser. Note that the following code changes in the HTML to the webpage with the reactive and also prints something in the console.

\[insert code showing reactive and observeEvent...\]

\[insert results of reactive\]

\[insert results of observeEvent\] - maybe a popup?

#### What is session?

Session is an optional argument passed to the server function that enables inputs or outputs related to the current instance of the app to be used. You may see some examples with this, such as with the downloadHandler() function.

If you see it in a code example, its likely there to and input or output that is unique to this instance and do something with it. You can experiment with removing it or adding it back in with this code;

\[insert session code example\]

### Summary

Reactivity is different due to the nature of declarative programming. It makes code less complex and provdies conditions that could be met, rather than a linear progression of code to be executed. We use reactivity so that people can change inputs and receive different outputs or make external actions happen.

Recognizing reactive functions of eventReactive() and observeEvent() and why its used on the back-end of a Shiny app will help in diagnosing and designing your code. The file upload input and the download button output are two examples where reactivity can be seen.

-   session is added as an optional argument to the server function call

-   put as much code before the shinyapp as possible to reduce calculation time.

-   eventReactive() is used for internal events triggering a change

-   observeEvent() is used for triggering external events, such as downloading a file to the users downloads folder.

## DataTables

## Computation output

## Visualization

### Basic graphs

### Network

## Dashboards

flexdashboard: [link](https://pkgs.rstudio.com/flexdashboard/articles/flexdashboard.html "dashboard basics")

uses R Markdown, easy, support static or dynamic visualizations, and uses CSS flexbox layout. (what's that?)

shinydashboard: [link](https://rstudio.github.io/shinydashboard/get_started.html "shiny dashboard")

shinuy UI code, not quite as easy, dynamic visualizations, and uses Bootstrap grid layout

### multiple graphs, tables, networks

### styling dashboards

#### The shinydashboard way

#### using shiny.semantic

https://appsilon.github.io/shiny.semantic/
