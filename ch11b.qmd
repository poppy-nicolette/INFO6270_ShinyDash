---
title: "Chapter 11b:"
subtitle: "Inputs and Outputs in Action"
format: 
  html:
    theme: "lumen"
editor: visual
toc: true
---

In this chapter, we'll be looking in more detail at the input and output functions by example using a standard R dataset. This chapter introduces you to:

-   input functions for text, numbers, dates, choices, file uploads and actions,

-   output functions for text, tables, plots, images, and download formats, and

-   an introduction to themes to change the appearance of your application.

You can see all the datasets included in R by typing `data()` in the console. You may also find the RStudio [cheatsheet](https://posit.co/resources/cheatsheets/) helpful to learn some hotkeys to speed up your workflow.

## Inputs & Widgets

Inputs are the ways users can enter, filter, or select information within your app. Widgets are a type of input that requires a different mode of input than text, such as a slider or button. There is a basic format to the inputs & widgets. First there is the input type, in this case a *`textAreaInput()`*. In the first position inside is the *inputID* parameter, followed by the label parameter. These two will be consistent with all inputs. After the *inputID* and the label, arguments that may be unique to each follow. In this case, there is an argument for the number of *rows*. In general, all inputs, (including widgets) keep this order of *inputID, label, arguments*.

``` r
textAreaInput("story", "Tell me about yourself", rows = 3)
```

While, we will address a few of these, you can find all of them and their code on the [shiny gallery](https://shiny.rstudio.com/gallery/widget-gallery.html)

The syntax of the widget the same as other inputs. Let's look at the code below:

![](images/Screen%20Shot%202023-02-17%20at%201.27.30%20PM.png)

The *inputID* has some rules, just like any variable in R. It must be a string consisting of letters, numbers, and/or underscores. Other characters like spaces, symbols, dashes, periods, etc., won't work. Second, it must be unique as you will call this in output functions.

You can find all of these in the input section in the shiny references documentation [here.](https://shiny.rstudio.com/reference/shiny/1.7.4/) The following selection are some of the more commonly used ones to get you started. Inputs and outputs will be shown in context of the ui or server component. You can build an app as you go along. You may want to start with the basic structure first and try different inputs as your read through the chapter.

``` r
library(shiny)

ui <- fluidPage(

)#close fluidPage

server <- function(input, output) {

} #close server function

shinyApp(ui, server)
```

::: callout-tip
If you ever want to know more about a function, you can always use the help section in RStudio or use the console to place a `?` before the function, such as `?fluidPage`.
:::

### Text input

##### textInput()

This is for small amounts of text, like asking for someone's name, address, or country. More info [here](https://shiny.rstudio.com/reference/shiny/0.14/textinput). To format text, for size, emphasis, color, etc, please see the *Formatting text* section at the end of the chapter.

``` r
ui <- fluidPage(
  textInput("input_1", "What's your favorite donut?"),
  )#close fluidPage
```

##### passwordInput()

This is for entering passwords. You can find more info [here](https://shiny.rstudio.com/reference/shiny/latest/passwordinput) on its arguments.

``` r
ui <- fluidPage(
  textInput("input_1", "What's your favorite donut?"),
  passwordInput("pword_1", "If a donut was your password, what would it be?")
)#close fluidPage
```

##### textAreaInput()

This one is better for longer sections of text, like bio's for websites, brief passages, comments, special instructions, etc. You can find more info [here](https://shiny.rstudio.com/reference/shiny/1.7.4/textareainput) on its arguments.

``` r
ui <- fluidPage(
  textInput("input_1", "What's your favorite donut?"),
  passwordInput("pword_1", "If a donut was your password, what would it be?"),
  textAreaInput("bio", "Please describe yourself as a donut", rows = 3)
  
)#close fluidPage
```

So, let's see these inputs as a complete application.

``` r
library(shiny)

ui <- fluidPage(
  textInput("input_1", "What's your favorite donut?"),
  passwordInput("pword_1", "If a donut was your password, what would it be?"),
  textAreaInput("bio", "Please describe yourself as a donut", rows = 3)
)#close fluidPage

server <- function(input, output){
}

# Run the application 
shinyApp(ui = ui, server = server)
```

### Number inputs

Here are three inputs for numbers.

##### numericInput()

``` r
ui <- fluidPage(
  numericInput("num_1", "Enter the quantity of donuts", value = 0, min = 0, max = 12)
)#close fluidPage
```

##### sliderInput()

Slider inputs can be used to select a single number or specify a range. Note the list argument passed in the second `sliderInput()` function named *num_3*.

``` r
ui <- fluidPage(
  sliderInput("num_2", "Enter the maximum number you can eat in one go", value = 6, min = 0, max = 12),
  sliderInput("num_3", "Enter the range of donuts you have been known to eat", value=c(3,9), min=0, max=12 )
)#close fluidPage
```

#### Dates

For single date entry, use the `dateInput()` function. For a range of dates, use the `dateRangeInput()`. Easy, right? There are format options for date inputs, such as `format`, `language`, and `value` which defines the starting date. The default starting date is today's date on your system. You can use the help section to find out more.

##### dateInput() and dateRangeInput()

``` r
ui <- fluidPage(
  dateInput("order_1", "What date do you want to order donuts?"),
  dateRangeInput("delivery_1","Between what dates do you want the donuts delivered?")

)#close fluidPage
```

#### Choices from a list

##### selectInput()

This provides a drop down list based on a list. In the following example, the list has been defined first, but this list could also be passed within the `selectInput()` function.

``` r
flavors <- c("chocolate", "plain", "raspberry", "maple", "unicorn", "creme-filled", "sprinkles", "chef's choice")

ui <- fluidPage(
  selectInput("flavor_1", "What flavor of donut would you like?", flavors)

)#close fluidPage
```

##### radioButtons()

Radio buttons provide a specified list of options that can be chosen. It is possible to change the text to other display types like images, icons, or HTML using the `choiceNames` and `choiceValues` aguments.

``` r
flavors <- c("chocolate", "plain", "raspberry", "maple", "unicorn", "creme-filled", "sprinkles", "chef's choice")

ui <- fluidPage(
  radioButtons("flavor_button", "What is your second favorite flavor?", flavors)

)#close fluidPage
```

##### checkboxInput() and checkboxGroupInput()

An alternative to radio buttons is check boxes which can be used for lists, surveys, or yes/no decions. For checkboxInput(), the value argument is a boolean TRUE or FALSE that determines if its automatically checked. `checkboxGroupInput()` also lets you select multiple choices, which the radio button does not.

``` r
flavors <- c("chocolate", "plain", "raspberry", "maple", "unicorn", "creme-filled", "sprinkles", "chef's choice")

ui <- fluidPage(
  checkboxInput("choice_1", "Eat here", value=TRUE),
  checkboxInput("choice_2", "Take home"),
  checkboxGroupInput("multiple_choice", "What flavors would you like?", flavors, selected = NULL)

)#closed fluidPage
```

::: callout-tip
By now, you should be using the `?function,` (such as `?checkboxGroupInput)` in the console or searching for the function in the help page, (usually on the right in RStudio). This is a normal part of workflow and will help you add arguments to control input behaviours.
:::

#### Action buttons

Actions are usually used with the `observeEvent()` or `eventReactive()` functions that trigger a server side function. We'll go over this in the next chapter. However, action buttons can alse be used for simple tasks without that reactivity.

##### actionButton()

There are different button types already formatted for you. These include `btn-primary`, `btn-success`, `btn-info`, `btn-warning`, or `btn-danger`. You can modify these with sizes, such as `btn-lg`, `btn-sm`, `btn-x`s.

``` r
ui <- fluidPage(
  fluidRow(
    actionButton("btn_1", "Place your order", class = "btn-primary"),
    actionButton("btn_2", "Reset your order", class = "btn-warning"),
    actionButton("btn_3", "Preview your order", class = "btn-info"),
    actionButton("btn_4", "Pay for your order", class = "btn-warning")
    ),#close fluidRow
    fluidRow(
    actionButton("btn_5", "I can't eat any more donuts", class = "btn-block")
  )#close fluidRow

)#close fluidPage
```

You can also pass icons from the [FontAwesome library](https://fontawesome.com/icons) to buttons and connect to web links.

``` r
ui <- fluidPage(
  actionButton(inputId='link_1', label="See our location", 
                          icon = icon("heart"), 
                          onclick ="window.open("https://goo.gl/maps/PrUi3qKEc3WFg9Hz7", '_blank')")
  )
)#close fluidPage
```

There are many more inputs available on the Shiny reference documentation, these most common ones will get you started making apps. OK! Enough with the donuts! Next, let's go over types of outputs and how these work with inputs using a standard R dataset

## Outputs

Outputs are assigned in the UI to define spaces where outputs will be seen. They include a unique ID in the first position of its arguments. UI outputs are always paired with a server output function.

Output ID's are called from the server side preceded by `output$outputID` in which `outputID` is the ID (like a variable name) you've assigned it. You'll see these are always calling a render\* function, such as `renderText()`. As an example:

![](images/Screen%20Shot%202023-02-17%20at%203.37.39%20PM.png){width="499"}

Some important new fuctions are called. In the `server()` function, you see `renderText()`. This calls the values you assigned in *`input_1`* and places it where you assigned it in *`output_1`*. In addition to text, you can also render tables, data tables, plots, images, and text. We'll look at these pairings of *`ui()`* outputs and *`server()`* outputs next.

#### Text output

##### textOutput() & renderText()

This outputs regular text. You can see the placeholder `textOutput()` in the ui, and the `renderText()` function passed in the server.

``` r
ui <- fluidPage(
  textOutput("text")

)#close fluidPage

server <- function(input, output) {
  output$text <- renderText({
  "Hello. The following is a summary of a standard R dataset, mtcars"
  })#close renderText
}#close server
```

##### verbatimTextOutput() & renderPrint()

This creates a console like output in the application. Lets add the dataset summary. `renderPrint()` prints the results of expressions, where `renderText()` prints text together in a string.

``` r
ui <- fluidPage(
  textOutput("text"),
  verbatimTextOutput("code")
  
)#close fluidPage

server <- function(input, output) {
  output$text <- renderText({
    "Hello. The following is a summary of a standard R dataset, mtcars"
  })
  output$code <- renderPrint({
    summary(mtcars)
  })
}#close server
```

#### Tables

Oh, tables! Tables are powerful. There are two types of tables, static tables of data, and dynamic tables that are interactive.

##### tableOutput() & renderTable()

Static tables are great for summaries or concise results. They're good at preserving data just the way you made it.

``` r
ui <- fluidPage(
  tableOutput("static")
)#close fluidPage

server <- function(input, output) {
  output$static <- renderTable(head(mtcars))
}#close server
```

##### dataTableOutput() & renderDataTable()

DataTables are much more dynamic and a have huge range of arguments of customizing behaviours.

``` r
ui <- fluidPage(
  dataTableOutput("dynamic")

)#close fluidPage

server <- function(input, output) {
  output$dynamic <- renderDataTable(mtcars, options=list(pageLength = 6)
  )#cloe renderDataTable
}#close server
```

DataTables are more appropriate for larger dataframes where someone may need to explore, filter, and sort data. You can find more information on modifying DataTables [here.](https://shiny.rstudio.com/articles/datatables.html)

There are two libraries that make DataTables amazing. One is reactable and the other is [DT](https://rstudio.github.io/DT/shiny.html). Both are great but reactable is much easier to use and integrate with Shiny and even Quarto.

::: callout-important
DataTables refers to both functions in Shiny and from the DT library. For any examples in this chapter, we'll be refering to the Shiny version.
:::

#### Plots

Plots are graphs and charts from packages like [ggplot2](https://r-graph-gallery.com/ggplot2-package.html), [plotly](https://plotly.com/r/), [r2d3,](https://rstudio.github.io/r2d3/) and many others. *Mastering Shiny* has an excellent [chapter](https://mastering-shiny.org/action-graphics.html) dedicated to ggplot2 for more info on making ggplot2 interactive. For now, we're going to stick with some simple ones to explain the basic plot output functions.

##### plotOutput() & renderPlot()

This work together to generate an R graphic, usually based on ggplot2 or similar graphic library.

``` r
library(shiny)
library(gglplot2)

ui <- fluidPage(
  plotOutput("plot", width = "400px")
)#close fluidPage
server <- function(input, output) {
  output$plot <- renderPlot(plot(1:10), res = 96)
}#close server

shinyApp(ui, server)
```

![A rather boring plot.](images/plot_output.png){width="450"}

Let's look at something more interesting. ggplot2 supports interactive mouse inputs, such as `click`, `dblclick`, `hover`, and `brush` (rectangular select). This time we're looking at the iris dataset.

``` r

library(shiny)
library(ggplot2)

ui <- fluidPage(
  plotOutput("plot", click = "plot_click"),
  tableOutput("data")
)
server <- function(input, output) {
  output$plot <- renderPlot({
    ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) + 
      geom_point()})
  
  output$data <- renderTable({
    nearPoints(iris, input$plot_click)
  })
}
shinyApp(ui, server) 
```

![](images/chart%20types.png)

![](images/scatterplot.png){width="900"}

More plot types can be found on the [R Graph Library](https://r-graph-gallery.com/) with helpful example code to get you started. This library focuses on ggplot 2 and tidyverse, so you have already learned what you need to make and modify these!

[![](images/chart%20types.png){width="900"}](https://r-graph-gallery.com/index.html)

#### Images

Images in your app as part of text. Of course, you also use `fluidRow()` and `column` arguments to organize your space with text and images.

``` r
library("shiny")
ui <- fluidPage(
      mainPanel(
        img(src='Donut.jpg', align = "center")
      )
    )#close fluidPage

server <- function(input, output) {

}#close server
shinyApp(ui, server)
```

Your files should be saved in a folder

     | shinyApp/
        | app.R
        | www/
           | Donut.jpg

#### File uploads

##### fileInput()

File uploads and downloads are more complicated types of inputs and outputs. There is a special chapter dedicated to them on the Mastering Shiny webbook [here](https://mastering-shiny.org/action-transfer.html). Loading data, usually in the form of a csv, is a very common need. The following code will upload a csv based on which dataset you've chosen based on an input menu. However, this code also makes the upload available to the servery function and reads it into a table.

``` r
library(shiny)

ui <- fluidPage(
    sidebarLayout(
      sidebarPanel(
        fileInput("file1", "Choose a CSV  format File", accept = ".csv"),
        checkboxInput("header", "Header", TRUE)
      ),
      mainPanel(
        tableOutput("contents")
      ) #close mainPanel
    )#close sidebarLayout
  )#close fluidPage
  
server <- function(input, output) {
    output$contents <- renderTable({
      file <- input$file1
      ext <- tools::file_ext(file$datapath)
      
      req(file)
      validate(need(ext == "csv", "Please upload a csv format file"))
      
      read.csv(file$datapath, header = input$header)
    })#close renderTable
  }#close function
  
shinyApp(ui, server)
```

#### Downloads

The download button is a special case and is not the same as a widget, however, it's a super useful output for people to download a dataset or whatever you have prepared for them. The `downloadHandler()` function is critical to this working. In this case the `downloadHandler()` is sending the file named *data* to the `write.csv()` function.

``` r
ui <- fluidPage(
  downloadButton("downloadData", "Download")
)

server <- function(input, output) {
  # Our dataset
  data <- mtcars

  output$downloadData <- downloadHandler(
    filename = function() {
      paste("data-", Sys.Date(), ".csv", sep=",")
    },
    content = function(file) {
      write.csv(data, file)
    }#close function
  )#close downloadHandler
}#close server function

shinyApp(ui, server)
```

With other libraries you can also write Excel files, such as with [*writexl*.](https://cran.r-project.org/web/packages/writexl/index.html) his version writes to an Excel file.

``` r
library(shiny)
library(writexl)


ui <- fluidPage(
    downloadButton("downloadData", "Download")
  )
  
server <- function(input, output) {
    # Our dataset
    data <- mtcars
    
    output$downloadData <- downloadHandler(
      filename = function() {
        #paste("data-", Sys.Date(), ".csv", sep="")
        paste("data-", Sys.Date(), ".xlsx")
      },
      content = function(file) {
        #write.csv(data, file)
        writexl::write_xlsx(data, file)
      } #close function
    ) #close downloadHandler
  }#close server function
  
shinyApp(ui, server)
```

Next, let's play with themes.

## Themes

Themes control the styling of the application, unifying colors and fonts, for example. Themes are assigned in the `ui()`. You can find the shinythemes library [here](https://rstudio.github.io/shinythemes/).

``` r
library(shinythemes)

ui = fluidPage(theme = shinytheme("cerulean")
  )#close fluidPage

server = function(input,output) {}

shinyApp(ui, server)
```

Or use the theme picker option until you decide on one!

``` r
library(shinythemes)

ui = fluidPage(
    shinythemes::themeSelector()
    )#close fluidPage
    
server = function(input, output) {}

shinyApp(ui, server)
  
```

It is possible to create your own themes, use themes other than Bootstrap, or modify Bootstrap themes to your own aesthetic needs. *Mastering Shiny* has a brief chapter on themes [here,](https://mastering-shiny.org/action-layout.html) and you can also find more information [here](https://bootswatch.com/) on Bootswatch themes. [Here is a link](https://www.w3schools.com/colors/default.asp) for the hex codes or names you'll need for colors.

To start making your own theme. Colors are hex or by HTML names. Collections of web safe fonts can be found [here.](https://www.w3schools.com/csSref/css_websafe_fonts.php)

``` r
theme <- bslib::bs_theme(
  bg = "#c4adca", 
  fg = "white", 
  base_font = "Times New Roman"
)
```

There is also the shiny.semantic library for a different look. You can find the link [here.](https://appsilon.github.io/shiny.semantic/)

## Formatting text

#### HTML functions

You can apply HTML equivalent functions in shiny to format your text by creating distinct paragraphs, emphasize text, or change the font or color. The table below shows the shiny function, such as p(), and its HTML equivalent and what is modified.

Table source: https://shiny.rstudio.com/tutorial/written-tutorial/lesson2/

| **shiny function** | **HTML5 equivalent** | **creates**                                      |
|:-------------------|:---------------------|:-------------------------------------------------|
| `p`                | `<p>`                | A paragraph of text                              |
| `h1`               | `<h1>`               | A first level header                             |
| `h2`               | `<h2>`               | A second level header                            |
| `h3`               | `<h3>`               | A third level header                             |
| `h4`               | `<h4>`               | A fourth level header                            |
| `h5`               | `<h5>`               | A fifth level header                             |
| `h6`               | `<h6>`               | A sixth level header                             |
| `a`                | `<a>`                | A hyper link                                     |
| `br`               | `<br>`               | A line break (e.g. a blank line)                 |
| `div`              | `<div>`              | A division of text with a uniform style          |
| `span`             | `<span>`             | An in-line division of text with a uniform style |
| `pre`              | `<pre>`              | Text \'as is\' in a fixed width font             |
| `code`             | `<code>`             | A formatted block of code                        |
| `img`              | `<img>`              | An image                                         |
| `strong`           | `<strong>`           | Bold text                                        |
| `em`               | `<em>`               | Italicized text                                  |
| `HTML`             |                      | Directly passes a character string as HTML code  |

Below is an example with many types of the HTML modifiers.

``` R
library(shiny)

ui <- fluidPage(
  titlePanel("My Shiny App"),
  sidebarLayout(
    sidebarPanel(),
    mainPanel(
      h1(" h1() creates a level 1 header."),
      h2(" h2() creates a level 2 header, and so on..."),
      p("Use p() to create a new paragraph. "),
      p("You can apply style to a paragraph using style", style = "font-family: 'times'; font-si16pt"),
      strong("Using strong() bolds text."),
      em("Italics can be applied with em(). "),
      br(),
      p("Use br() to apply a line break."),
      br(),
      code("You can create a code box with code()."),
      div("div creates a container that can apply styles within it using 'style = color:magenta'", style = "color:blue"),
      br(),
      p("span is similar to div but can affect smaller sections",
        span("such as words or phrases", style = "color:purple"),
        "within a paragraph or body of text."),
      h3(p("You can also combine ", 
           em(span("HTML", style="color:magenta")), 
           "functions."))
    )#close mainPanel
  )#close sidebarLayout
)#close fluidPage
server <- function(input, output) {
  
}

shinyApp(ui, server)
```

## Wrap up

That's chapter 11b! By the end of this you have learned more about many of the Shiny inputs and output functions, how they work together, an introduction to themes, and formatting text.

In the next chapter, we'll look at reactivity and how to create dashboards!!
